#include <toneAC.h>
#include <Button.h>

Button palanca = Button (8, BUTTON_PULLUP_INTERNAL, true, 50);
int LED = 11;
int SPEAKER = 12;
int emisor = 4;
int sensor = 2;
int valve = 5;
int castigo = 7;
int leds = 6;
int sync = A4;

unsigned long cue_time;
unsigned long sensor_time;
unsigned long currentMicros;

boolean listening = true;
boolean available_trial = true; // para saber si se puede empezar un nuevo trial o no.
boolean sensor_bool = false;
boolean go_bool = false;
boolean cue_bool = false;
boolean true_press = false;

int sensor_state;
int palanca_state;

int queue_type[100];
unsigned long queue_time[100];


void cue()
{
  int cues = random (1,6);
  digitalWrite(sync, HIGH);
  delay(5);
  digitalWrite(sync, LOW);
  available_trial = false;
  if (cues == 1 || cues == 2 || cues == 3) // BIMODAL CUE
  {
    Serial.println("***GO CUE");
    //Serial.println(currentMicros/1000);
    go_bool = true;
    //nogo_bool = false;
    digitalWrite(LED, HIGH);
    digitalWrite (leds, HIGH);
    for( int volume = 0 ; volume <= 10; volume++) 
    {
      toneAC(1000, volume);
    }
    listening=false;
    enqueue(1,currentMicros+(500000));

  }
  
  if (cues == 4 || cues == 5 || cues == 6) // BIMODAL NOGO CUE
  {
    Serial.println("***NOGO CUE");
    go_bool = false;
    digitalWrite(leds, HIGH);
    for( int volume = 0 ; volume <= 10; volume++) 
    {
      toneAC(5500, volume);
    }
    listening=false;
    enqueue(3,currentMicros+(500000));
    
  } 

}

void non_cue()
{
  int poll = random (1,3);
  digitalWrite(sync, HIGH);
  delay(5);
  digitalWrite(sync, LOW);
  available_trial = false;
  if (poll == 1)
  {
    //catch_trial = true;
    Serial.println("***CATCH");
    Serial.println("___________________");
    Serial.println("___________________");
    listening = false;
    enqueue(8,currentMicros+(200000));
    
  }
  
  if (poll == 2)
  {
    //catch_trial = false;
    Serial.println("***NEUTRAL 1");
    digitalWrite(LED, HIGH);
    for( int volume = 0 ; volume <= 10; volume++) 
    {
      for (int freq = 300 ; freq <= 8000; freq = freq+50)
      {
        toneAC(freq, volume);
      }
    }
    listening=false;
    enqueue(8,currentMicros+(500000));
  }
}


void onPress(Button& b){
  if (listening==true   && available_trial == true)
  {
    
    unsigned long variable_delay = random (300000,500001);
    available_trial = false;
    enqueue(6,currentMicros+(variable_delay));     // LA PALANCA DEBE SER APRETADA POR AL MENOS 300 MILISEGUNDOS

    Serial.println("___________________");
    Serial.println("Press: ");
    Serial.println(currentMicros/1000);
    Serial.println("                   ");
    Serial.println("ON HOLD: ");
    Serial.println(variable_delay/1000);
    Serial.println("                   ");

  }
}

void onRelease(Button& b)
{
  if (true_press == true)
  {
    
    Serial.println("Release: ");
    Serial.println(currentMicros/1000);
    Serial.println("                   ");
    Serial.println("___________________");
  }
  true_press = false;
}

void enqueue(int orden, unsigned long time) {
  int i;
//  Serial.print("Enqueue ");
//  Serial.println(currentMicros);
  for (i=0; i<100;i++) {
    if (queue_type[i]==0) {
      queue_type[i] = orden;
      queue_time[i] = time;
      i = 100;
    }
  }
}

void dequeue() {
  int i;
  
  for (i=0; i<100;i++) {
    if (queue_type[i]==5) {
      if (queue_time[i] < currentMicros || sensor_state == HIGH) {
//        Serial.print("Dequeue ");
//        Serial.println(currentMicros);
        //Serial.println("Sensor reading Complete");
        queue_type[i]=0;
        if (go_bool) {
          if (sensor_state == HIGH) {
            Serial.println("Nose-poke: ");
            Serial.println(currentMicros/1000);
            Serial.println("                   ");
            digitalWrite(valve, LOW);
            Serial.println("11");
            Serial.println("___________________");
            Serial.println("___________________");
            enqueue(4, currentMicros+1000000);
            available_trial = true;
            
          }
          else {
            Serial.println("MISS: ");
            Serial.println(currentMicros/1000);
            Serial.println("                   ");
            Serial.println("13");
            Serial.println("___________________");
            Serial.println("___________________");
            available_trial = true;

          }
       }
       
       else // if go_bool == false...
       {
         if (sensor_state == HIGH) {
           Serial.println("Nose-poke: ");
           Serial.println(currentMicros/1000);
           Serial.println("                   ");
           Serial.println("22");
           Serial.println("___________________");
           Serial.println("___________________");
           digitalWrite(castigo, HIGH);
           //tone(SPEAKER,7000);//DEBUG
           listening = false;
           enqueue(2,currentMicros+6000000);
           
        }
        else
        {
          Serial.println("HIT: ");
          Serial.println(currentMicros/1000);
          Serial.println("                   ");
          Serial.println("23");
          Serial.println("___________________");
          Serial.println("___________________");
          available_trial = true;
        }
       }
      }
    }
    
    if (queue_type[i]!=0 && queue_time[i] < currentMicros) {
//        Serial.print("Dequeue ");
//        Serial.println(currentMicros);
      if (queue_type[i]==1) {
        
        digitalWrite(LED, LOW);
        digitalWrite(leds, LOW);
//        noTone(SPEAKER);
        toneAC();
        listening = true;
      }
      else if (queue_type[i]==2) {
        //Serial.println("Castigo over");
        digitalWrite(castigo, LOW);
        listening = true;
        available_trial = true;
        //noTone(SPEAKER);// DEBUG
      }
      else if (queue_type[i]==3) {
        //Serial.println("NOGO CUE");
        digitalWrite(leds, LOW);
//        noTone(SPEAKER);
        toneAC();
        listening = true;
      }
      else if (queue_type[i]==4) {
        //Serial.println("REWARD");
        digitalWrite(valve, HIGH);
        
      }
      else if (queue_type[i]==6) 
      {
        
        if (palanca_state == LOW) 
        {
          //Serial.println("TRUE PRESS");
          true_press = true;
          int cue_type = random (1,4);
          
          if (cue_type == 1 || cue_type == 2)
          {
            cue();
            enqueue(5,currentMicros+1500000);
          }
          
          if (cue_type == 3)
          {
            non_cue();
            enqueue(7,currentMicros+1500000);
          }         
        }
        
        else
        {
          Serial.println("FALSE PRESS");
          Serial.println("___________________");
          Serial.println("___________________");
          available_trial = true;
        }
      }
      
      else if (queue_type[i]==7) 
      {
       if (queue_time[i] < currentMicros || sensor_state == HIGH) 
       {
         queue_type[i]=0;
        
           if (sensor_state == HIGH)
           {
              Serial.println("Nose-poke: ");
              Serial.println(currentMicros/1000);
              Serial.println("                   ");
              Serial.println("___________________");
              Serial.println("___________________");
              available_trial = true;
                          
          }
          else
          {
            Serial.println("no response: ");
            Serial.println(currentMicros/1000);
            Serial.println("                   ");
            Serial.println("___________________");
            Serial.println("___________________");
            available_trial = true;           
          }
         
       }
      }
      
      else if (queue_type[i]== 8) 
      {
        digitalWrite(LED, LOW);
        digitalWrite(leds, LOW);
        toneAC();
        listening = true;

      }
      
      
      queue_type[i]=0;
    }
    
  }
}

void setup()
{
  int i;
  for (i=0; i < 100; i++) {
    queue_type[i] = 0;
    queue_time[i] = 0;
  }
  
  Serial.begin(9600);
  Serial.println("Started");
  pinMode(LED,OUTPUT); //debug to led 13
  pinMode(SPEAKER, OUTPUT);
  pinMode(valve, OUTPUT);
  digitalWrite(valve, HIGH);
  pinMode(sensor, INPUT);
  pinMode(emisor, OUTPUT);
  pinMode(castigo, OUTPUT);
  digitalWrite(emisor, HIGH);
  pinMode(leds, OUTPUT);

  // Assign callback functions
  palanca.pressHandler(onPress);
  palanca.releaseHandler(onRelease);
//  palanca.holdHandler(onHold, 1000); // must be held for at least 1000 ms to trigger
}

void loop()
{

   currentMicros = micros();
   sensor_state = digitalRead(sensor);
   palanca_state = digitalRead(8);
   dequeue();
//    if(currentMillis - previousMillis >= interval) {
//    previousMillis = currentMillis;
  
  // update the buttons' internals
 
  palanca.process();
}
  
